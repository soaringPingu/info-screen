import sys# For handling of time and time zone informationimport datetime  # time of day etc.import pytz# imports related to web scrapingimport requestsimport json# import urllib.requestfrom PyQt5 import QtSvg, QtWidgetsfrom PyQt5.QtGui import QPixmap, QStandardItemModel, QStandardItem, QImage, QPainter, QColorfrom bs4 import BeautifulSoup# Use PyQt5 to allow direct use of Qt UI filesfrom PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox, QTableWidgetItem, QLabel, QStyledItemDelegate, \    QAbstractItemView, QGroupBoxfrom PyQt5.QtCore import QTimer, QUrl, Qt, QModelIndex, QAbstractItemModel, QSize, QVariant# import the GUIfrom ui_gösta_v2 import Ui_MainWindow# Enumeration supportfrom enum import IntEnum# Error logging facilitydef error_handling(error, message, window_handler=None):    # This function will write the error and message with    # a time stamp to a log file in the project root, unless    # another location is given in a config file.    # If the logging to file fails, then it will attempt to    # open a message box. If that also fails, then the error    # will be printed to the Python console.    log_file_name = "errors.log"    utc_now = pytz.utc.localize(datetime.datetime.utcnow())    now_se = utc_now.astimezone(pytz.timezone("Europe/Stockholm"))    time_stamp = now_se.strftime('%b %d %Y %H:%M:%S')    # Open the file in "append" mode and create the file if it does not exist    try:        with open(log_file_name, "a+") as log_file:            log_file.write(f"{time_stamp}\t | {error}\t | {message}\n")    except Exception as e:        if window_handler is None:            print("No window handler was passed to the error_handling function, and the log file failed.")            print(f"The error message was:\n{error}\n{message}")        else:            window_handler.msg = QMessageBox()            window_handler.msg.setIcon(QMessageBox.Warning)            window_handler.msg.setWindowTitle("Error log problem")            window_handler.msg.setText("There was a problem logging an error")            window_handler.msg.setInformativeText(f"{time_stamp}\nThe error I wanted to log was: \n{message}")            window_handler.msg.setDetailedText(f"The error while trying to log was:\n{str(e)}")            window_handler.msg.show()'''# Class for making a bus icon. It is needed to provide a painter section to render the imageclass MiniBusIconWidget(QStandardItem):    """    Set itself to an image of a minibus for use in the bus time table    Information from:    https://stackoverflow.com/questions/5553342/adding-images-to-a-qtablewidget-in-pyqt    """    def __init__(self, parent):        super(MiniBusIconWidget, self).__init__(parent)        self.picture = QPixmap("ui/transport/Minibus_white_30x30.png")    def paintEvent(self, event):        painter = QPainter(self)        painter.drawPixmap(0, 0, self.picture)# Class for making a minibus icon. It is needed to provide a painter section to render the imageclass MiniBusIconWidget2(QLabel):    """    Set itself to an image of a minibus for use in the bus time table    Information from:    https://stackoverflow.com/questions/5553342/adding-images-to-a-qtablewidget-in-pyqt    """    def __init__(self, parent=None):        super(MiniBusIconWidget2, self).__init__(parent)        picture = QPixmap("ui/transport/Minibus_white_30x30.png")        self.setPixmap(picture)# Class for making a bus icon. It is needed to provide a painter section to render the imageclass BusIconWidget(QtWidgets.QWidget):    """    Set itself to an image of a bus for use in the bus time table    Information from:    https://stackoverflow.com/questions/5553342/adding-images-to-a-qtablewidget-in-pyqt    """    def __init__(self, parent):        super(BusIconWidget, self).__init__(parent)        self.picture = QPixmap("ui/transport/Bus_white_30x30.png")    def paintEvent(self, event):        painter = QtGui.QPainter(self)        painter.drawPixmap(0, 0, self.picture)class ImageDelegate(QStyledItemDelegate):    """    Custom image delegate to paint an image inside a QTableView item    """    # Information from:    # https://stackoverflow.com/questions/6464741/qtableview-with-a-column-of-images    def __init__(self, parent):        QStyledItemDelegate.__init__(self, parent)    def paint(self, painter, option, index):        painter.fillRect(option.rect, QColor(91, 122, 85))        # path = "path\to\my\image.jpg"        #if index.model().:        path = "ui/transport/Minibus_white_30x30.png"        image = QImage(str(path))        pixmap = QPixmap.fromImage(image)        #pixmap.scaled(50, 40, Qt.KeepAspectRatio)        painter.drawPixmap(option.rect, pixmap)    def sizeHint(self, option, index):        return QSize(30, 30)  # whatever your dimensions are'''class TransportType(IntEnum):    """ Create enum for modes of transport """    NONE = 0    BUS = 1    MINIBUS = 2    TRAIN = 3class AlignmentType(IntEnum):    """ Create enum for alignment types """    LEFT = 0    CENTRE = 1    RIGHT = 2# Class handling bus time informationclass BusInformation:    def __init__(self, table_view: QtWidgets.QTableView, bus_group_box: QtWidgets.QGroupBox, window_handler):        """        This class has methods for retrieving and displaying Bus information        Methods:        get_data: Collects on-line data to be displayed according to the settings in the config file        :param table_view: QTableView object into which the data should be written        """        # Make local variables for the widget items        self.__window = window_handler        self.__group = bus_group_box        self.__table = table_view        # Define variables and give them default values        self.__stop_name = "Bus Stop"        self.__stop_id = -1        self.__line_number = -1        self.__route_start_location = "No start"        self.__route_end_location = "No end"        self.__trafiklab_API_key_ResRobot_tidtabell = ""        self.__trafiklab_API_key_ResRobot_reseplanerare = ""        self.__trafiklab_API_key_GTFS = ""        self.__model = QStandardItemModel(1, 5)        self.__bus_data = []        # Configure the group box        self.__group.setTitle("Busstider - COOP Sundborn")        # call method to read the configuration file        self.__read_config()        # call method to configure the table view, e.g. set static headers        self.__init_table_view()        # Make an initial data collection on object creation        self.get_data()    def __init_table_view(self):        """        Initialize the QTableView widget used for Bus information        Set up things like column count, header, at least one row with 'No Data' in it,        row heights and column widths, etc.        """        # Set table headers        self.__model.setHorizontalHeaderLabels(["Typ", "Linje", "Destination", "Tid", "Ny tid"])        # Assign the display model to the widget        self.__table.setModel(self.__model)        # Set column widths        header_h = self.__table.horizontalHeader()        header_h.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)        header_h.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)        header_h.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)        header_h.setSectionResizeMode(3, QtWidgets.QHeaderView.ResizeToContents)        header_h.setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)        header_h.setStretchLastSection = False  # Override default behaviour        header_h.highlightSections = False        header_h.minimumSectionSize = 30        # Header_h colours        header_h.setStyleSheet("background-color: rgb(0, 79, 8);")        # header_h.resizeSection(0, 30)        # Row header settings        header_v = self.__table.verticalHeader()        header_v.setVisible(False)        # Set selection functionality (for displaying data only, no interaction        self.__table.setAlternatingRowColors(False)        self.__table.setSelectionMode(QAbstractItemView.NoSelection)        self.__table.clearSelection()        self.__table.setEditTriggers(QAbstractItemView.NoEditTriggers)        # Set colours        border = "gridline-color: rgb(245, 121, 0);"        # Linear gradient from colour at stop 1 to colour at stop 2        # Default is to overlay a white gradient which only changes transparency        background = "background-color: qlineargradient(" \                     "spread:pad, x1: 0.5, y1: 0, x2: 0.5, y2: 1, " \                     "stop: 0 rgba(255, 255, 255, 0), " \                     "stop: 1         rgba(255, 255, 255, 50));"        selection_background = "selection-background-color: transparent;"        self.__table.setStyleSheet(f"{border} {selection_background} {background}")    '''    def __debug_print(self):        print(f"Bus stop: {self.__stop_name}")        print(f"Bus line number: {self.__line_number}")        print(f"Start location: {self.__route_start_location}")        print(f"End location: {self.__route_end_location}")        print(f"Tidtabell API Key: {self.__trafiklab_API_key_ResRobot_tidtabell}")        print(f"Reseplanerare API key: {self.__trafiklab_API_key_ResRobot_reseplanerare}")        print(f"GTFS API key: {self.__trafiklab_API_key_GTFS}")    '''    def __destination_name_filter(self, destination):        # Run a number of replace functions on the destinations to replace a full name with a given name        # if destination == "Falun Centralstation":        #    return "Falun C"        # if destination == "Backafors (Falun kn)":        #    return "Backafors"        # if destination == "Toftbyn (Falun kn)":        #    return "Toftbyn"        # if destination == "Sundbornsskolan skolbusshållplats (Falun kn)":        #    return "Sundbornsskolan"        if " (Falun kn)" in destination:            destination = destination.replace(" (Falun kn)", "")        return destination    def __display_data(self, departures):        """        Display the supplied Bus information in the internal table view widget        The data in the provided bus_data structure will be displayed in the internally referenced        QTableView widget.        :param departures: Structure containing the bus data to be displayed        """        previous_time = 0  # To indicate if the departure is on next day        offset = 0  # Offset between input data and output row        display_count = 0  # Used to limit the number of displayed rows        # Loop through each destination        for row in range(len(departures)):            new_time = int(departures[row]["time"].split(":")[0])  # Save the hours as an integer            if new_time < previous_time and display_count <= 5:  # New day, and room for one more item after it                self.__model.setItem(row + offset, 0, self.__get_transport_icon(TransportType.NONE))                self.__model.setItem(row + offset, 1,                                     self.__get_text_item("", AlignmentType.CENTRE))                self.__model.setItem(row + offset, 2,                                     self.__get_text_item("--== Ny Dag ==--", AlignmentType.CENTRE))                self.__model.setItem(row + offset, 3,                                     self.__get_text_item("", AlignmentType.CENTRE))                display_count += 1                offset += 1            previous_time = new_time            # Add transport Icon            if departures[row]["transport_type"] == str(TransportType.BUS):                self.__model.setItem(row + offset, 0, self.__get_transport_icon(TransportType.BUS))            elif departures[row]["transport_type"] == str(TransportType.MINIBUS):                self.__model.setItem(row + offset, 0, self.__get_transport_icon(TransportType.MINIBUS))            else:                self.__model.setItem(row + offset, 0, self.__get_transport_icon(TransportType.NONE))            # Set the text based information            self.__model.setItem(row + offset, 1,                                 self.__get_text_item(str(departures[row]["line"]), AlignmentType.CENTRE))            self.__model.setItem(row + offset, 2,                                 self.__get_text_item(str(departures[row]["direction"]), AlignmentType.CENTRE))            self.__model.setItem(row + offset, 3,                                 self.__get_text_item(str(departures[row]["time"]), AlignmentType.CENTRE))            display_count += 1            if display_count >= 7:                break  # Exit Loop    def get_data(self):        """ Read the bus information data from the online API and display it """        bus_departure = {"transport_type": "", "line": "", "time": ""}        departures = []        # From: https://www.trafiklab.se/api/resrobot-stolptidtabeller-2/dokumentation/avgaende-trafik        # Example        # https://api.resrobot.se/v2/departureBoard?key=<DIN NYCKEL>&id=<HÅLLPLATSID>&maxJourneys=<MAX ANTAL SVAR>        # More info on using API's in Python        # https://www.pythonforbeginners.com/python-on-the-web/how-to-access-various-web-services-in-python        # TEMP Find bus stop ID using Lat & Long        # url = f"https://api.resrobot.se/v2/location.nearbystops?key={self.trafiklab_API_key_ResRobot_reseplanerare}&originCoordLat=60.6531517&originCoordLong=15.7744094&format=xml"        # request = requests.get(url)        # print(request.text)        # try:        url = f"https://api.resrobot.se/v2/departureBoard?key={self.__trafiklab_API_key_ResRobot_tidtabell}&id={self.__stop_id}&maxJourneys=20&format=json"        request = requests.get(url)        # print(f">{request}>")                     # DEBUG        if str(request) == "<Response [200]>":  # We have a connection and some data            bus_data = json.loads(request.text)  # returns a python data structure            # print(bus_data)                       # DEBUG            # TODO We have the data, now we need to filter on buses heading towards Falun, set the number of changes            # Loop through the result.            count = 0            for item in bus_data["Departure"]:                # Filter out any bus lines that are not of interest                if item['transportNumber'] == self.__line_number:                    departures.append(bus_departure.copy())  # Add a departure dictionary                    if "Buss" in item['Product']['name']:                        departures[count]["transport_type"] = str(TransportType.BUS)                    elif "Taxi" in item['Product']['name']:                        departures[count]["transport_type"] = str(TransportType.MINIBUS)                    departures[count]["line"] = item['transportNumber']                    departures[count]["time"] = item["time"][:-3]                    departures[count]["direction"] = self.__destination_name_filter(str(item["direction"]))                    # print(departures[count])      # DEBUG                    # print()                       # DEBUG                    count += 1        self.__display_data(departures)        # TODO get the current traffic info with live bus data        # except Exception as e:        #    print(str(e))        # error_handling(f"Error with ReseRobot API", f"Error message: {str(e)}", self.window_handler)    @staticmethod    def __get_transport_icon(transport_type: TransportType):        """        Return an icon for the selected TransportType - Only bus types are considered        :return: QStandardItem containing an image        """        if transport_type == TransportType.BUS:            image = QImage("ui/transport/Bus_white_30x30.png")        elif transport_type == TransportType.MINIBUS:            image = QImage("ui/transport/Minibus_white_30x30.png")        else:            # Image when no known transport is used            image = QImage()  # Empty image        # Make the image usable in the QTableView, based in a QStandardItem        item = QStandardItem()        item.setData(QVariant(QPixmap.fromImage(image)), Qt.DecorationRole)        return item    def __get_text_item(self, text, alignment: AlignmentType):        """        Return a QStandardItem containing a text which is aligned according to the supplied parameter        Text items are always aligned centrally in the vertical direction        :param text: The text to add to the item        :param alignment: The alignment to assign to the item        :return: A QStandardItem containing the given text        """        item = QStandardItem(text)        if alignment == AlignmentType.RIGHT:            item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)        elif alignment == AlignmentType.CENTRE:            item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)        else:            item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)        return item    def __read_config(self):        """        Read configuration file for the Bus departure information        Try read the Bus information configuration file which specifies things like        what data is to be collected, how to display it and what API-keys to use.        If there is no configuration file, or there is an error when trying to read it,        an error will be logged in the logging system.        """        config_file_name = "bus_info.cfg"        # Try to open the file and read all lines in it to a variable        # https://www.pythonforbeginners.com/files/reading-and-writing-files-in-python        try:            with open(config_file_name, "r") as bus_config:                data_lines = bus_config.readlines()                # loop through the lines and split the data. If it matches a property, read it                for line in data_lines:                    if line[0] != "#":  # Exclude comments                        temp_text = line.split("=")                        cfg_name = temp_text[0]                        cfg_data = temp_text[1]                        if len(temp_text) == 3:                            cfg_data_ext = temp_text[2]                        if cfg_name.strip() == "bus_stop":                            self.__stop_id = cfg_data.strip()                            self.__stop_name = cfg_data_ext.strip()                        if cfg_name.strip() == "bus_line_number":                            self.__line_number = cfg_data.strip()                        if cfg_name.strip() == "bus_start_location":                            self.__route_start_location = cfg_data.strip()                        if cfg_name.strip() == "bus_end_location":                            self.__route_end_location = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_ResRobot_tidtabell":                            self.__trafiklab_API_key_ResRobot_tidtabell = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_ResRobot_reseplanerare":                            self.__trafiklab_API_key_ResRobot_reseplanerare = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_GTFS":                            self.__trafiklab_API_key_GTFS = cfg_data.strip()            # "With" means file.close() is not required, it is automatic        except FileNotFoundError:            error_handling(f"Missing bus config file", f"Could not open the file \"{config_file_name}\"",                           self.__window)        except Exception as e:            error_handling(f"Error reading config file", f"Error message: {str(e)}", self.__window)class DateTime:    """ A class handling the date and time information on the Info Screen """    def __init__(self, date_time_group: QtWidgets.QGroupBox, window_handler):        """        This class has methods for showing the current time and date as well as if anything is happening on this day        Methods:        get_time: Gets the current time and date for the primary (and secondary) groups and displays this        get_occasion: Gets the current occasion(s) and displays this        get_event: Gets the current event for this day, if any, and displays this. E.g. "Christmas Eve"        :param date_time_group: The group box for this data group        """        # Make local variables for the widget items        self.__window = window_handler        self.__group = date_time_group        self.__primary_time_label = QLabel        self.__primary_day_label = QLabel        self.__primary_date_label = QLabel        self.__primary_month_label = QLabel        self.__primary_occasion_label = QLabel        self.__primary_week_label = QLabel        self.__secondary_time_label = QLabel        self.__secondary_day_label = QLabel        self.__secondary_date_label = QLabel        self.__secondary_month_label = QLabel        self.__secondary_occasion_label = QLabel        self.__secondary_week_label = QLabel        # internal variables        self.__primary_time_string = ""        self.__primary_day_string = ""        self.__primary_date_string = ""        self.__primary_month_string = ""        self.__primary_occasion_string = ""        self.__primary_week_string = ""        self.__secondary_time_string = ""        self.__secondary_day_string = ""        self.__secondary_date_string = ""        self.__secondary_month_string = ""        self.__secondary_occasion_string = ""        self.__secondary_week_string = ""        self.__widgets = self.__get_group_widgets(self.__group)   # Get a list of all the widgets in the group        # Settings related variables        self.__setting_display_secondary_group = False        self.__setting_display_primary_seconds = True        self.__setting_display_secondary_seconds = False        self.__setting_primary_time_zone = "Europe/Stockholm"        self.__setting_secondary_time_zone = "Pacific/Auckland"        # Format strings, replace (T1) in primary and secondary, with hh:mm, and (T2) in primary, with ":ss"        self.__primary_time_format_string = "<html><head/><body><p><span style=\" font-size:48pt;\">(T1)</span>" \                                            "<span style=\" font-size:14pt;\">(T2)</span></p></body></html>"        self.__primary_time_format_string = "<html><head/><body><p><span style=\" font-size:20pt;\">(T1)</span>" \                                            "<span style=\" font-size:10pt;\">(T2)</span></p></body></html>"        # Configure the group box        self.__group.setTitle("Idag")        # call method to read the configuration file        # self.__read_config()        # Make an initial data collection on object creation        self.get_time()        self.get_occasion()    def __display_data(self):        """        Display the current data in all the widgets in this group                 This is an internal helper method which is called from the get_time() and get_date() methods        """        try:            temp_strings = self.__primary_time_string.split(":")            t1 = f"temp_strings[0]:temp_strings[1]"            t2 = f":temp_strings[2]"        except:            t1 = "??:??"            t2 = ":??"        # make the time string by replacing the fixed items (T1) and (T2) in the format string        if self.__setting_display_primary_seconds:            time_string = self.__primary_time_format_string.replace("(T1)", str(t1))            time_string = str(time_string.replace("(T2)", str(t2)))        else:            time_string = self.__primary_time_format_string.replace("(T1)", str(t1))            time_string = str(time_string.replace("(T2)", ""))        self.__primary_time_label = time_string        self.__primary_day_label = self.__primary_day_string        self.__primary_date_label = self.__primary_date_string        self.__primary_month_label = self.__primary_month_string        self.__primary_occasion_label = self.__primary_occasion_string        self.__primary_week_label = self.__primary_week_string        try:            temp_strings = self.__secondary_time_string.split(":")            t1 = f"temp_strings[0]:temp_strings[1]"            t2 = f":temp_strings[2]"        except:            t1 = "??:??"            t2 = ":??"        # make the time string by replacing the fixed items (T1) and (T2) in the format string        if self.__setting_display_secondary_seconds:            time_string = self.__primary_time_format_string.replace("(T1)", str(t1))            time_string = str(time_string.replace("(T2)", str(t2)))        else:            time_string = self.__primary_time_format_string.replace("(T1)", str(t1))            time_string = str(time_string.replace("(T2)", ""))        self.__secondary_time_label = time_string        self.__secondary_day_label = self.__secondary_day_string        self.__secondary_date_label = self.__secondary_date_string        self.__secondary_month_label = self.__secondary_month_string        self.__secondary_occasion_label = self.__secondary_occasion_string        self.__secondary_week_label = self.__secondary_week_string    def get_occasion(self):        """ Get the current occasion for the primary and secondary display """        self.__primary_occasion_string = "Nu är det jul igen!"        self.__primary_occasion_string = "Happy New Year!"                self.__display_data()    def get_time(self):        """ Get the current time and date for the primary and secondary time displays """            days = ["Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag", "Söndag"]        months = ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober",                  "November", "December"]        utc_now = pytz.utc.localize(datetime.datetime.utcnow())        now_primary = utc_now.astimezone(pytz.timezone(self.__setting_primary_time_zone))        now_secondary = utc_now.astimezone(pytz.timezone(self.__setting_secondary_time_zone))                self.__primary_time_string = f"{now_primary.hour}:{now_primary.minute:02}:{now_primary.second:02}"        self.__primary_day_string = f"{days[now_primary.weekday()]}"        self.__primary_date_string = f"{now_primary.day}"        self.__primary_month_string = f"{months[now_primary.month - 1]}"        self.__primary_week_string = f"v {now_primary.strftime('%W')}"        self.__secondary_time_string = f"{now_secondary.hour}:{now_secondary.minute:02}:{now_secondary.second:02}"        self.__secondary_day_string = f"{days[now_secondary.weekday()]}"        self.__secondary_date_string = f"{now_secondary.day}"        self.__secondary_month_string = f"{months[now_secondary.month - 1]}"        self.__secondary_week_string = f"v {now_secondary.strftime('%W')}"        self.__display_data()    @staticmethod    def __get_group_widgets(self, group: QGroupBox):        """ Return a list of all widgets in a group box object """        # Adapted from: https://stackoverflow.com/questions/5150182/loop-over-widgets-in-pyqt-layout        # return (group.childAt(i) for i in range(group.children().count()))        widgets = []        for i in range(group.children().count()):            widgets.append(group.childAt(i))        return widgets    def __read_config(self):        """        Read configuration file for the Bus departure information        Try read the Bus information configuration file which specifies things like        what data is to be collected, how to display it and what API-keys to use.        If there is no configuration file, or there is an error when trying to read it,        an error will be logged in the logging system.        """        config_file_name = "bus_info.cfg"        # Try to open the file and read all lines in it to a variable        # https://www.pythonforbeginners.com/files/reading-and-writing-files-in-python        try:            with open(config_file_name, "r") as bus_config:                data_lines = bus_config.readlines()                # loop through the lines and split the data. If it matches a property, read it                for line in data_lines:                    if line[0] != "#":  # Exclude comments                        temp_text = line.split("=")                        cfg_name = temp_text[0]                        cfg_data = temp_text[1]                        if len(temp_text) == 3:                            cfg_data_ext = temp_text[2]                        if cfg_name.strip() == "bus_stop":                            self.__stop_id = cfg_data.strip()                            self.__stop_name = cfg_data_ext.strip()                        if cfg_name.strip() == "bus_line_number":                            self.__line_number = cfg_data.strip()                        if cfg_name.strip() == "bus_start_location":                            self.__route_start_location = cfg_data.strip()                        if cfg_name.strip() == "bus_end_location":                            self.__route_end_location = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_ResRobot_tidtabell":                            self.__trafiklab_API_key_ResRobot_tidtabell = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_ResRobot_reseplanerare":                            self.__trafiklab_API_key_ResRobot_reseplanerare = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_GTFS":                            self.__trafiklab_API_key_GTFS = cfg_data.strip()            # "With" means file.close() is not required, it is automatic        except FileNotFoundError:            error_handling(f"Missing bus config file", f"Could not open the file \"{config_file_name}\"",                           self.__window)        except Exception as e:            error_handling(f"Error reading config file", f"Error message: {str(e)}", self.__window)# Class handling bus time informationclass Quote:    """ Get data and present a quote on the information screen """    def __init__(self, quote_group_box: QtWidgets.QGroupBox, quote_widget: QLabel, quotee_widget: QLabel):        """        This class has methods for retrieving and displaying a quote        Methods:        get_data: Collects on-line data to be displayed according to the settings in the config file        :param table_view: QTableView object into which the data should be written        """        # Make local variables for the widget items        self.__group = quote_group_box        self.__quote_widget = quote_widget        self.__quotee_widget = quotee_widget        # Define variables and give them default values        self.__quote_text = ""        self.__quotee_text = ""        # Configure the group box        self.__group.setTitle("Dagens citat")        # call method to read the configuration file        # self.__read_config()        # call method to configure the graphical elements        self.__init_widgets()        # Make an initial data collection on object creation        self.get_data()    def __init_widgets(self):        """        Initialize the widgets used in the Quote class        Set up things like look and feel, colours, size alignment etc.        """        # Define variables and give them default values        self.__quote_text = "Nothing wise to say..."        self.__quotee_text = "No Name"        # Position the labels        self.__quotee_widget.setGeometry(self.__quote_widget.geometry().left(),                                         self.__quote_widget.geometry().bottom() + 10,                                         self.__quote_widget.geometry().width(),                                         self.__quote_widget.geometry().height()                                         )        '''        # Set colours        border = "gridline-color: rgb(245, 121, 0);"        # Linear gradient from colour at stop 1 to colour at stop 2        # Default is to overlay a white gradient which only changes transparency        background = "background-color: qlineargradient(" \                     "spread:pad, x1: 0.5, y1: 0, x2: 0.5, y2: 1, " \                     "stop: 0 rgba(255, 255, 255, 0), " \                     "stop: 1         rgba(255, 255, 255, 50));"        selection_background = "selection-background-color: transparent;"        self.__table.setStyleSheet(f"{border} {selection_background} {background}")        '''        self.__display_data()    def __display_data(self):        """ Display the supplied information in the quote widgets """        # Set the quote text and the quotee text        self.__quote_widget.setText(self.__quote_text)        self.__quotee_widget.setText(self.__quotee_text)        # adjust the sizes        self.__quote_widget.adjustSize()        self.__quotee_widget.adjustSize()    def get_data(self):        """ Read the quote information from the given source """        temp_url = "https://adafruit.com"        response = requests.get(temp_url)        if str(response) == "<Response [200]>":            # Get the data            soup = BeautifulSoup(response.text, "html.parser")            # Get the quote            # get all span-tags            tags = soup("span")            # find the tag with the attribute class quoteClass (syntax found through commandline trial and error)            for tag in tags:                if str(tag.attrs) == "{'class': ['quoteClass']}":                    self.__quote_text = tag.contents[0]            # Get the quotee            tags = soup("div")            # find the tag with the attribute class quoteClass (syntax found through commandline trial and error)            for tag in tags:                if str(tag.attrs) == "{'class': ['quoteAttribution']}":                    # The tag has two content parts, one line break [0], and one a-tag [1]. Parse the a-tag                    self.__quotee_text = f"-{tag.contents[1].text}"            self.__display_data()    def __read_config(self):        """        Read configuration file for the Bus departure information        Try read the Bus information configuration file which specifies things like        what data is to be collected, how to display it and what API-keys to use.        If there is no configuration file, or there is an error when trying to read it,        an error will be logged in the logging system.        """        config_file_name = "bus_info.cfg"        # Try to open the file and read all lines in it to a variable        # https://www.pythonforbeginners.com/files/reading-and-writing-files-in-python        try:            with open(config_file_name, "r") as bus_config:                data_lines = bus_config.readlines()                # loop through the lines and split the data. If it matches a property, read it                for line in data_lines:                    if line[0] != "#":  # Exclude comments                        temp_text = line.split("=")                        cfg_name = temp_text[0]                        cfg_data = temp_text[1]                        if len(temp_text) == 3:                            cfg_data_ext = temp_text[2]                        if cfg_name.strip() == "bus_stop":                            self.__stop_id = cfg_data.strip()                            self.__stop_name = cfg_data_ext.strip()                        if cfg_name.strip() == "bus_line_number":                            self.__line_number = cfg_data.strip()                        if cfg_name.strip() == "bus_start_location":                            self.__route_start_location = cfg_data.strip()                        if cfg_name.strip() == "bus_end_location":                            self.__route_end_location = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_ResRobot_tidtabell":                            self.__trafiklab_API_key_ResRobot_tidtabell = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_ResRobot_reseplanerare":                            self.__trafiklab_API_key_ResRobot_reseplanerare = cfg_data.strip()                        if cfg_name.strip() == "trafiklab_API_key_GTFS":                            self.__trafiklab_API_key_GTFS = cfg_data.strip()            # "With" means file.close() is not required, it is automatic        except FileNotFoundError:            error_handling(f"Missing bus config file", f"Could not open the file \"{config_file_name}\"",                           self.__window)        except Exception as e:            error_handling(f"Error reading config file", f"Error message: {str(e)}", self.__window)class MainWindow(QMainWindow):    def __init__(self):        ######################################################################################        # Link to best information so far for connecting widgets to code:                    #        # https://ethicalhackingguru.com/getting-started-building-a-python-gui-using-pyqt5/  #        ######################################################################################        super(MainWindow, self).__init__()        self.ui = Ui_MainWindow()        self.ui.setupUi(self)        # Enable/disable frameless program window        # self.setWindowFlags(Qt.FramelessWindowHint)        # Create and initialize various information section classes        self.bus_information = BusInformation(self.ui.busTableView, self.ui.busGroup, self.ui)        self.quote_group = Quote(self.ui.quoteGroup, self.ui.quote_label, self.ui.quotee_label)        self.time_group = DateTime(self.ui.timeGroup, self.ui)        # Indicator that an error has occurred        self.active_fault = False        # Timers for fast and slow data updates        self.date_time_timer = QTimer()        self.date_time_timer.setInterval(500)  # 0.5 seconds        self.date_time_timer.timeout.connect(self.update_data_fast)        self.date_time_timer.start()        '''        self.slow_timer = QTimer()        self.slow_timer.setInterval(30000)  # 30 seconds        self.slow_timer.timeout.connect(self.update_data_slow)        # self.slow_timer.start()        '''        self.quote_timer = QTimer()        self.quote_timer.setInterval(1000 * 60 * 60 * 6)  # every 6 hours [1 second * 60 seconds * 60 minutes * 6 hours]        self.quote_timer.timeout.connect(self.quote_group.get_data)        self.quote_timer.start()        self.quote_group.get_data()  # Get initial quote    def update_weather(self):        """ Update the weather data for the information screen when called by its associated timer """        # TODO get weather        # based on information from        # https://towardsdatascience.com/how-to-web-scrape-with-python-in-4-minutes-bc49186a8460        url_weather = "https://www.smhi.se/q/Sundborn/Falun/2670900"        response = requests.get(url_weather)        error_handling("An error occurred", "Extended error text", self)        if response == "200":            # Get the data            self.ui.temp_label.setText(f"Data finns!")        else:            self.ui.temp_label.setText(f"Ingen data")        self.bus_information.get_data()if __name__ == "__main__":    app = QApplication(sys.argv)    window = MainWindow()    window.show()    sys.exit(app.exec_())