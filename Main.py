import sys# For handling of time and time zone informationimport datetime  # time of day etc.import pytz# imports related to web scrapingimport requestsimport urllib.requestfrom bs4 import BeautifulSoup# Use PyQt5 to allow direct use of Qt UI filesfrom PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBoxfrom PyQt5.QtCore import QTimer, QUrl# import the GUIfrom ui_gösta import Ui_MainWindow# Error logging facilitydef error_handling(error, message, window_handler=None):    # This function will write the error and message with    # a time stamp to a log file in the project root, unless    # another location is given in a config file.    # If the logging to file fails, then it will attempt to    # open a message box. If that also fails, then the error    # will be printed to the Python console.    log_file_name = "errors.log"    utc_now = pytz.utc.localize(datetime.datetime.utcnow())    now_se = utc_now.astimezone(pytz.timezone("Europe/Stockholm"))    time_stamp = now_se.strftime('%b %d %Y %H:%M:%S')    # Open the file in "append" mode and create the file if it does not exist    try:        with open(log_file_name, "a+") as log_file:            log_file.write(f"{time_stamp}\t | {error}\t | {message}\n")    except Exception as e:        if window_handler is None:            print("No window handler was passed to the error_handling function, and the log file failed.")            print(f"The error message was:\n{error}\n{message}")        else:            window_handler.msg = QMessageBox()            window_handler.msg.setIcon(QMessageBox.Warning)            window_handler.msg.setWindowTitle("Error log problem")            window_handler.msg.setText("There was a problem logging an error")            window_handler.msg.setInformativeText(f"{time_stamp}\nThe error I wanted to log was: \n{message}")            window_handler.msg.setDetailedText(f"The error while trying to log was:\n{str(e)}")            window_handler.msg.show()# Class handling bus time informationclass BusInformation:    def __init__(self, window_handler=None):        ######################################################################################        # Class to handle bus station information.                                           #        # It will look for a configuration file with bus line information and license key    #        # information. This will be in the project root                                      #        ######################################################################################        self.bus_stop = "Bus Stop"        self.bus_line_number = -1        self.bus_start_location = "No start"        self.bus_end_location = "No end"        self.trafiklab_API_key_ResRobot = ""        self.trafiklab_API_key_GTFS = ""        self.window_handler = window_handler        self.read_config()    def debug_print(self):        print(f"Bus stop: {self.bus_stop}")        print(f"Bus stop: {self.bus_line_number}")        print(f"Bus stop: {self.bus_start_location}")        print(f"Bus stop: {self.bus_end_location}")        print(f"Bus stop: {self.trafiklab_API_key_ResRobot}")        print(f"Bus stop: {self.trafiklab_API_key_GTFS}")    def get_data(self):        # TODO read data for the chosen bus route / stop / etc.        a = 0    def read_config(self):        # Reads a configuration file, if there is one        config_file_name = "bus_info2.cfg"        # Try to open the file and read all lines in it to a variable        # https://www.pythonforbeginners.com/files/reading-and-writing-files-in-python        try:            with open(config_file_name, "r") as bus_config:                data_lines = bus_config.readlines()                # loop through the lines and split the data. If it matches a property, read it                for line in data_lines:                    temp_text = line.split("=")                    cfg_name = temp_text[0]                    cfg_data = temp_text[1]                    if cfg_name.strip() == "bus_stop":                        self.bus_stop = cfg_data.strip()                    if cfg_name.strip() == "bus_line_number":                        self.bus_line_number = cfg_data.strip()                    if cfg_name.strip() == "bus_start_location":                        self.bus_start_location = cfg_data.strip()                    if cfg_name.strip() == "bus_end_location":                        self.bus_end_location = cfg_data.strip()                    if cfg_name.strip() == "trafiklab_API_key_ResRobot":                        self.trafiklab_API_key_ResRobot = cfg_data.strip()                    if cfg_name.strip() == "trafiklab_API_key_GTFS":                        self.trafiklab_API_key_GTFS = cfg_data.strip()            # "With" means file.close() is not required, it is automatic        except FileNotFoundError:            error_handling(f"Missing bus config file", f"Could not open the file \"{config_file_name}\"",                           self.window_handler)        except Exception as e:            error_handling(f"Error reading config file", f"Error message: {str(e)}", self.window_handler)class MainWindow(QMainWindow):    def __init__(self):        ######################################################################################        # Link to best information so far for connecting widgets to code:                    #        # https://ethicalhackingguru.com/getting-started-building-a-python-gui-using-pyqt5/  #        ######################################################################################        super(MainWindow, self).__init__()        self.ui = Ui_MainWindow()        self.ui.setupUi(self)        bus_information = BusInformation(self)        # Indicator that an error has occurred        self.active_fault = False        # Timers for fast and slow data updates        self.fast_timer = QTimer()        self.fast_timer.setInterval(500)  # 0.5 seconds        self.fast_timer.timeout.connect(self.update_data_fast)        self.fast_timer.start()        self.slow_timer = QTimer()        self.slow_timer.setInterval(30000)  # 30 seconds        self.slow_timer.timeout.connect(self.update_data_slow)        self.slow_timer.start()        self.quote_timer = QTimer()        self.quote_timer.setInterval(1000*60*60*6)  # every 6 hours [1 second * 60 seconds * 60 minutes * 6 hours]        self.quote_timer.timeout.connect(self.get_new_quote)        self.quote_timer.start()        self.get_new_quote()    # Get initial quote    def update_data_fast(self):        days = ["Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag", "Söndag"]        months = ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober",                  "November", "December"]        utc_now = pytz.utc.localize(datetime.datetime.utcnow())        now_se = utc_now.astimezone(pytz.timezone("Europe/Stockholm"))        now_nz = utc_now.astimezone(pytz.timezone("Pacific/Auckland"))        self.ui.se_time_label.setText(f"{now_se.hour}:{now_se.minute:02}:{now_se.second:02}")        self.ui.se_day_label.setText(f"{days[now_se.weekday()]}")        self.ui.se_date_label.setText(f"{now_se.day}")        self.ui.se_month_label.setText(f"{months[now_se.month - 1]}")        self.ui.se_occation_label.setText("En vanlig dag...")        self.ui.se_week_label.setText(f"v {now_se.strftime('%W')}")        self.ui.nz_time_label.setText(f"{now_nz.hour}:{now_nz.minute:02}")        self.ui.nz_day_label.setText(f"{days[now_nz.weekday()]}")        self.ui.nz_date_label.setText(f"{now_nz.day}")        self.ui.nz_month_label.setText(f"{months[now_nz.month - 1]}")        # TODO get the number of minutes left for a bus to arrive/leave    def update_data_slow(self):        # TODO get weather        # based on information from        # https://towardsdatascience.com/how-to-web-scrape-with-python-in-4-minutes-bc49186a8460        url_weather = "https://www.smhi.se/q/Sundborn/Falun/2670900"        response = requests.get(url_weather)        error_handling("An error occurred", "Extended error text", self)        if response == "200":            # Get the data            self.ui.temp_label.setText(f"Data finns!")        else:            self.ui.temp_label.setText(f"Ingen data")        # Get bus information        # https://www.trafiklab.se/projekt/informationstavla-familjen        api_key_gtfs = "384d8b7083814bab818a396f4f142397"        api_key_res_robot = "a2c8c460-6d8b-45e9-90b3-9342332acb72"        # url_bus = "https: // reseplanerare.resrobot.se / index.html  # !P|SQ!histId|1!histKey|H765130"))        url_bus = "https://reseplanerare.resrobot.se/#!P|TP data - s = \"Sundborn affären (Falun kn)\" data - z = \"Kristinegymnasiet (Falun kn)\""        url_bus = "https://reseplanerare.resrobot.se/#!P|TP\" data-s=\"Sundborn affären (Falun kn)\" data-z=\"Kristinegymnasiet (Falun kn)\""        response = requests.get(url_bus)        if str(response) == "<Response [200]>":            # Get the data            # Get the data            soup = BeautifulSoup(response.text, "html.parser")            # get all span-tags            tags = soup("span")            # find the tag with the attribute class quoteClass (syntax found through commandline trial and error)            for tag in tags:                if str(tag.attrs) == "{'class': ['quoteClass']}":                    quote = tag.contents[0]        # TODO get bus info    def get_new_quote(self):        quote = "\"Imagine a problem is an apple and face it with a hungry attitude.\""        quotee = "Kaisa Wallner, 17:e Oktober, 2019"        temp_url = "https://adafruit.com"        response = requests.get(temp_url)        if str(response) == "<Response [200]>":            # Get the data            soup = BeautifulSoup(response.text, "html.parser")            # Get the quote            # get all span-tags            tags = soup("span")            # find the tag with the attribute class quoteClass (syntax found through commandline trial and error)            for tag in tags:                if str(tag.attrs) == "{'class': ['quoteClass']}":                    quote = tag.contents[0]            # Get the quotee            tags = soup("div")            # find the tag with the attribute class quoteClass (syntax found through commandline trial and error)            for tag in tags:                if str(tag.attrs) == "{'class': ['quoteAttribution']}":                    # The tag has two content parts, one line break [0], and one a-tag [1]. Parse the a-tag                    quotee = f"-{tag.contents[1].text}"        # set the labels        self.ui.quote_label.setText(quote)        self.ui.quotee_label.setText(quotee)        # adjust the sizes        self.ui.quote_label.adjustSize()        self.ui.quotee_label.adjustSize()        # Position the labels        self.ui.quotee_label.setGeometry(self.ui.quote_label.geometry().left(),                                         self.ui.quote_label.geometry().bottom() + 10,                                         self.ui.quote_label.geometry().width(),                                         self.ui.quote_label.geometry().height()                                         )if __name__ == "__main__":    app = QApplication(sys.argv)    window = MainWindow()    window.show()    sys.exit(app.exec_())